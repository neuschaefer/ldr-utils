AT_SETUP(create)

AT_LDR_CHECK(LDR_BINARY -q -c moo cow, [1], [], [dnl
ldr: please select a target with -T <target>
])

AT_LDR_CHECK(LDR_BINARY -q -T BF537 -c out.ldr /bin/bash, [1], [], [dnl
ldr: '/bin/bash' is not a Blackfin ELF!
Failed to create LDR: Bad file descriptor
])

AT_LDR_CHECK([
LDR_BINARY -T BF548 -c post.ldr ELFS_DIR/POST.dxe
echo "### --- ###"
LDR_BINARY --show post.ldr
], [0], [dnl
Creating LDR post.ldr ...
 Adding DXE 'elfs/POST.dxe' ... [[jump block] [ELF block: 29612 @ 0xFFA00000] [ELF block: 7280 @ 0xFF800000]] OK!
Done!
### --- ###
Showing LDR post.ldr ...
auto detected LDR as 'BF548'
  DXE 1 at 0x00000000:
    Block  1 at 0x00000000
         Addr: 0xFFA00000 BCode: 0xAD7F5001 Bytes: 0x00000000 Args: 0x0000904C ( 8bit-dma-from-8bit ignore first )
    Block  2 at 0x00000010
         Addr: 0xFFA00000 BCode: 0xAD0E0001 Bytes: 0x000073AC Args: 0xDEADBEEF ( 8bit-dma-from-8bit )
    Block  3 at 0x000073CC
         Addr: 0xFF800000 BCode: 0xAD9D0001 Bytes: 0x00001C70 Args: 0xDEADBEEF ( 8bit-dma-from-8bit )
    Block  4 at 0x0000904C
         Addr: 0xFFA00000 BCode: 0xAD738001 Bytes: 0x00000000 Args: 0x00000000 ( 8bit-dma-from-8bit final )
])

AT_LDR_CHECK([
LDR_BINARY -T BF561 -c bss.ldr ELFS_DIR/bss.elf
echo "### --- ###"
LDR_BINARY --show bss.ldr
], [0], [dnl
Creating LDR bss.ldr ...
 Adding DXE 'elfs/bss.elf' ... [[jump block] [ELF block: 968 @ 0x00000000] [ELF block: 1144 @ 0x000013C8]] OK!
Done!
### --- ###
Showing LDR bss.ldr ...
auto detected LDR as 'BF561'
  LDR header: A00000DE ( 8-bit-flash wait:15 hold:3 spi:500K )
  DXE 1 at 0x00000000:
    Block  1 at 0x00000000
         Addr: 0xFFA00000 Bytes: 0x0000000C Flags: 0x0002 ( resvect )
    Block  2 at 0x00000016
         Addr: 0x00000000 Bytes: 0x000003C8 Flags: 0x0002 ( resvect )
    Block  3 at 0x000003E8
         Addr: 0x000013C8 Bytes: 0x00000034 Flags: 0x0002 ( resvect )
    Block  4 at 0x00000426
         Addr: 0x000013FC Bytes: 0x00000444 Flags: 0x8003 ( zerofill resvect final )
])

AT_LDR_CHECK([
LDR_BINARY -T BF532 -c bad.ldr ELFS_DIR/bad.elf
], [1], [dnl
Creating LDR bad.ldr ...
 Adding DXE 'elfs/bad.elf' ... ], [dnl
ldr: 'elfs/bad.elf' is not a static ELF!
Failed to create LDR: Bad file descriptor
])

AT_LDR_CHECK([
LDR_BINARY -T BF536 -c section.ldr ELFS_DIR/section.elf
], [0], [dnl
Creating LDR section.ldr ...
 Adding DXE 'elfs/section.elf' ... [[init block 2] [jump block] [ELF block: 2 @ 0x00000000]] OK!
Done!
])

AT_LDR_CHECK([
LDR_BINARY -T bf544-0.0 -c hole-4x-split.ldr ELFS_DIR/POST.dxe --punchit 0x40:0x70
LDR_BINARY -T bf544-0.0 -c hole-4x-expan.ldr ELFS_DIR/POST.dxe --punchit 0x30:0x70
LDR_BINARY -T bf534-0.3 -c hole-3x-split.ldr ELFS_DIR/POST.dxe --punchit 0x40:0x70
LDR_BINARY -T bf534-0.3 -c hole-3x-expan.ldr ELFS_DIR/POST.dxe --punchit 0x10:0x70
echo "### --- ###"
LDR_BINARY --quiet -s hole-4x-split.ldr
LDR_BINARY --quiet -s hole-4x-expan.ldr
LDR_BINARY --quiet -s hole-3x-split.ldr
dnl The --target here is needed because the autodetect only works
dnl if the first block is a load into L1 rather than an ignore
LDR_BINARY --target BF533 --quiet -s hole-3x-expan.ldr
], [0], [dnl
Creating LDR hole-4x-split.ldr ...
 Adding DXE 'elfs/POST.dxe' ... [[jump block] [ELF block: 29612 @ 0xFFA00000] [ELF block: 7280 @ 0xFF800000]] OK!
Done!
Creating LDR hole-4x-expan.ldr ...
 Adding DXE 'elfs/POST.dxe' ... [[jump block] [ELF block: 29612 @ 0xFFA00000] [ELF block: 7280 @ 0xFF800000]] OK!
Done!
Creating LDR hole-3x-split.ldr ...
 Adding DXE 'elfs/POST.dxe' ... [[jump block] [ELF block: 29612 @ 0xFFA00000] [ELF block: 7280 @ 0xFF800000]] OK!
Done!
Creating LDR hole-3x-expan.ldr ...
 Adding DXE 'elfs/POST.dxe' ... [[jump block] [ELF block: 29612 @ 0xFFA00000] [ELF block: 7280 @ 0xFF800000]] OK!
Done!
### --- ###
dnl
dnl this one should split the first load block into two pieces
dnl
  DXE 1 at 0x00000000:
              Offset      BlockCode  Address    Bytes      Argument
    Block  1 0x00000000: 0xADEF5001 0xFFA00000 0x00000000 0x000090DC ( 8bit-dma-from-8bit ignore first )
    Block  2 0x00000010: 0xADC10001 0xFFA00000 0x00000010 0xDEADBEEF ( 8bit-dma-from-8bit )
dnl The important part is that the ignore block have an offset of
dnl (start-block_header_size), or in this case, (0x40 - 16 == 0x30)
    Block  3 0x00000030: 0xAD261001 0x00000000 0x00000070 0xBAADF00D ( 8bit-dma-from-8bit ignore )
dnl Then we need to make sure that the next block has an offset of
dnl (start+offset), or in this case, (0x40 + 0x70 == 0xB0)
    Block  4 0x000000B0: 0xAD2E0001 0xFFA00010 0x0000739C 0xDEADBEEF ( 8bit-dma-from-8bit )
    Block  5 0x0000745C: 0xAD9D0001 0xFF800000 0x00001C70 0xDEADBEEF ( 8bit-dma-from-8bit )
    Block  6 0x000090DC: 0xAD738001 0xFFA00000 0x00000000 0x00000000 ( 8bit-dma-from-8bit final )
dnl
dnl this one should expand the hole
dnl
  DXE 1 at 0x00000000:
              Offset      BlockCode  Address    Bytes      Argument
    Block  1 0x00000000: 0xADEF5001 0xFFA00000 0x00000000 0x000090DC ( 8bit-dma-from-8bit ignore first )
dnl Here we see that the hole makes sure to end at an offset of
dnl (start+offset), or in this case, (0x30 + 0x70 == 0xA0) and that
dnl the size of the hole was expanded from 0x70 to 0x80 to fill the
dnl leading gap (since we couldn't split the punched block)
    Block  2 0x00000010: 0xADD61001 0x00000000 0x00000080 0xBAADF00D ( 8bit-dma-from-8bit ignore )
    Block  3 0x000000A0: 0xAD0E0001 0xFFA00000 0x000073AC 0xDEADBEEF ( 8bit-dma-from-8bit )
    Block  4 0x0000745C: 0xAD9D0001 0xFF800000 0x00001C70 0xDEADBEEF ( 8bit-dma-from-8bit )
    Block  5 0x000090DC: 0xAD738001 0xFFA00000 0x00000000 0x00000000 ( 8bit-dma-from-8bit final )
dnl
dnl this one should split the first load block into two pieces
dnl
  DXE 1 at 0x00000000:
              Offset      Address     Bytes    Flags
    Block  1 0x00000000: 0xFFA00000 0x0000002C 0x0002 ( resvect )
dnl The important part is that the ignore block have an offset of
dnl (start-block_header_size), or in this case, (0x40 - 10 == 0x36)
    Block  2 0x00000036: 0x00000000 0x00000070 0x0012 ( resvect ignore )
dnl Then we need to make sure that the next block has an offset of
dnl (start+offset), or in this case, (0x40 + 0x70 == 0xB0)
    Block  3 0x000000B0: 0xFFA0002C 0x00007380 0x0002 ( resvect )
    Block  4 0x0000743A: 0xFF800000 0x00001C70 0x8002 ( resvect final )
dnl
dnl this one should expand the hole
dnl
  DXE 1 at 0x00000000:
              Offset      Address     Bytes    Flags
dnl Here we see that the hole makes sure to end at an offset of
dnl (start+offset), or in this case, (0x10 + 0x70 == 0x80) and that
dnl the size of the hole was expanded from 0x70 to 0x76 to fill the
dnl leading gap (since we couldn't split the punched block)
    Block  1 0x00000000: 0x00000000 0x00000076 0x0012 ( resvect ignore )
    Block  2 0x00000080: 0xFFA00000 0x000073AC 0x0002 ( resvect )
    Block  3 0x00007436: 0xFF800000 0x00001C70 0x8002 ( resvect final )
])

AT_CLEANUP
